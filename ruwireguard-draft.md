# Ru-WireGuard: Использование российских криптографических алгоритмов в протоколе безопасности сетевого уровня WireGuard

## Содержание
- [Введение](#введение)
- [Обозначения](#обозначения)
- [Криптографические вычисления](#криптографические-вычисления)
  - [Используемые российские криптографические алгоритмы](#используемые-российские-криптографические-алгоритмы)
  - [Представление точек эллиптической кривой](#представление-точек-эллиптической-кривой)
  - [Константы](#константы)
- [Протокол Handshake](#протокол-handshake)
  - [Обработка первого сообщения](#обработка-первого-сообщения)
  - [Обработка второго сообщения](#обработка-второго-сообщения)
  - [Вычисление кодов аутентификации сообщений](#вычисление-кодов-аутентификации-сообщений)
  - [Вычисление ключевого материала](#вычисление-ключевого-материала)
  - [Защита данных](#защита-данных)
  - [Формирование сообщения Cookie Reply](#формирование-сообщения-cookie-reply)
- [Контрольные вектора](#контрольные-вектора)

## Введение

Настоящий документ содержит описание протокола безопасности сетевого уровня WireGuard с российскими криптографическими алгоритмами.
 
Необходимость разработки настоящего документа вызвана потребностью в применении современного протокола безопасности сетевого уровня WireGuard
в отечественных перспективных сетевых, распределенных и облачных технологиях, например, таких, как SD-WAN,
построенных с применением средств криптографической защиты информации.

Данное описание выполнено в стиле основной спецификации ["WireGuard: Next Generation Kernel Network Tunnel"](https://www.wireguard.com/papers/wireguard.pdf).
При этом в данном документе описываются и уточняются основные положения касательно применения российских криптографических методов и алгоритмов.
Все вносимые изменения касаются только секции 5.4 раздела 5 “Protocol and Cryptography”. 

Данный документ может быть использован в качестве отправной точки для разработки рекомендаций по стандартизации протокола WireGuard
с российскими криптографическими алгоритмами или как спецификация для реализации последнего.

Данный документ не может быть использован отдельно без оригинальной спецификации WireGuard.

## Обозначения

ε – битовая строка нулевой длины

[b]^s – двоичная строка вида b, b, …, b состоящая из s бит b

b^s – двоичная строка вида b, b, …, b состоящая из s байт b

⌈r⌉ – наименьшее целое число, большее или равное r

|| – конкатенация двух байтовых строк

|b| - длина байтовой строки

b[i] – значение бита i в битовой строке b

Vm – переменная, принадлежащая стороне m; m=i, если сторона - инициатор соединения (initiator) и m=r, если сторона - ответчик(responder)

Для сообщений и переменных, которые могут быть создана любой из сторон: если сторона является инициатором, то (m, m') = (i, r),
если сторона является ответчиком, то (m, m') = (r, i).

Im – 32-х битный индекс, идентифицирующий противоположную сторону (аналог SPI в IPsec)

(Sm-priv, Sm-pub ) – статическая ключевая пара

(Em-priv, Em-pub ) – эфемерная ключевая пара

Q – опциональный предварительно-распределенный секрет, равный 032 по-умолчанию

Hm, Cm – текущие значения хэш–функции (hash value) и цепного ключа (chaining key value)

Tm-send, Tm-recv – ключевой материал для шифрования и расшифрования

Nm-send, Nm-recv – уникальные вектора для шифрования и расшифрования

## Криптографические вычисления

Везде далее при работе с байтами используется обратный порядок (little-endian), если другое не оговорено.

### Используемые российские криптографические алгоритмы

#### Алгоритм согласования ключа
В качестве алгоритма согласования ключа KEK_VKO(x, Y, UKM) используется алгоритм [VKO_GOSTR3410_2012_256](https://tc26.ru/standard/rs/%D0%A0%2050.1.113-2016.pdf).
Операции над точками эллиптических кривых задаются в соответствии с ГОСТ Р 34.10–2012.

DH-Generate() – функция генерации ключевой пары, соответствующей эллиптической кривой GC256A (полный идентификатор кривой [id-tc26-gost-3410-2012-256-paramSetA](https://tools.ietf.org/html/rfc7836)).

Функция DH определена следующим образом: DH(x, Y) = KEK_VKO(x, Y, UKM),
где x – закрытый ключ, Y – открытый ключ противоположной стороны, UKM = 1, а ключевые пары (x, X), (y, Y) получены с использованием функции DH-Generate().

#### Блочный шифр
В качестве блочного шифра используется шифр “Кузнечик”, определенный в ГОСТ Р 34.12–2015.
Размер блока составляет 16 байт, длина ключа составляет 32 байта.

#### AEAD алгоритм 
В качестве AEAD алгоритма используется режим MGM работы блочного шифра, описанный в Р 1323565.1.026–2019, с длиной имитовставки S равной 16 байт.

Функция шифрования AEAD-Encrypt задается следующим образом: 
С || T = AEAD-Encrypt(K, N, P, A) = MGM-Encrypt(K, ICN, A, P), где K – ключ зашифрования,
A – дополнительные имитозащищаемые данные, N – уникальный вектор длиной 8 байт (64 бита),
ICN = [0]^7 || 0^7 || N – уникальный вектор размера 127 бит, состоящий из 63-х нулевых бит, за которыми следует вектор N,
P – открытый текст, C – шифртекст, T – имитовставка.

Функция расшифрования AEAD-Decrypt задается следующим образом: 
AEAD-Decrypt(K, N, P, C || T) = P, если MGM-Decrypt(K, ICN, A, C, T) = (A, P) и 丄, если при выполнении MGM-Decrypt(K, ICN, A, C, T) произошла ошибка.

#### Хэш–функция
В качестве хэш-функции Hash(input) используются хэш-функция ГОСТ Р 34.11-2012 с длиной выхода 32 байта (256 бит).

#### HMAC алгоритм
В качестве функции Hmac(key, input), используется алгоритм HMAC_GOSTR3411_2012_256 на основе заданной хэш–функции ГОСТ Р 34.11-2012
с длиной выхода 32 байта (256 бит).

#### KDF алгоритм
В качестве функции KDFn(key, input) используется алгоритм диверсификации ключей KDF_TREE_GOSTR3411_2012_256.

Функция KDFn определяется следующей формулой:
KDFn(K, input) = KDF_TREE_GOSTR3411_2012_256(K, KDF-Label(n), input). 

Результатом применения функции KDFn(K, input) является набор ключей (k1, …, kn), каждый из которых имеет размер 32 байта.

Функция KDF-Label(n) определена так: 
 - KDF-Label(1) = KDF_LABEL_1
 - KDF-Label(2) = KDF_LABEL_2
 - KDF-Label(3) = KDF_LABEL_3

KDF_LABEL_1, KDF_LABEL_2, KDF_LABEL_3 являются константами определенными в секции ["Константы"](https://github.com/bi-zone/ruwireguard-spec/new/main#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D1%8B).

#### Функция Timestamp
Функция Timestamp() возвращает значение [TAI64N](https://cr.yp.to/libtai/tai64.html) для текущего времени длиной 12 байт,
где первые 8 байт соответствуют количеству секунд с 1970 TAI и последние 4 байта соответствуют количеству наносекунд начиная с секунды представленной TAI64.
Байты представлены в сетевом порядке (прямом, big–endian).

### Представление точек эллиптической кривой

#### Функция MarshalCompressed
Функция MarshalCompressed преобразует кооординаты точки на эллиптический кривой в байтовое представление в сжатом формате на основе алгоритма 4.3.6
стандарта ANSI X9.62.

#### Функция UnmarshalCompressed
Функция UnmarshalCompressed по байтовому представлению в сжатом формате получает координаты точки на эллиптический кривой на основе алгоритма 4.3.6
стандарта ANSI X9.62.

### Константы

#### Construction
Строка, длиной 57 байт, состоящая из следующих UTF–8 символов:
“Noise_IKpsk2_GC256A_GOST_R_341112_256_WITH_KUZNYECHIK_MGM”.

#### Identifier
Строка, длиной 42 байта, состоящая из следующих UTF–8 символов:
“RU WireGuard v1 2020 zx2c4 Jason@zx2c4.com”.

#### Label–Mac1
Строка, длиной 16 байт, состоящая из UTF-8 символов “RU mac1---- 2020”.

#### Label–Cookie
Строка, длиной 16 байт, состоящая из UTF-8 символов “RU cookie-- 2020”.

#### Константы для KDF
В функции KDFn используются следующие строки, длиной 32 байта:
 - KDF_LABEL_1 = "KDF_GOST_R_3411_2012_256_LABEL_1"
 - KDF_LABEL_2 = "KDF_GOST_R_3411_2012_256_LABEL_2"
 - KDF_LABEL_3 = "KDF_GOST_R_3411_2012_256_LABEL_3"

## Протокол Handshake
В большинстве случаев в протоколе Handshake каждая из сторон отправляет по одному сообщению другой стороне,
после чего стороны могут начать передавать зашифрованные данные.
Если одна из сторон находится под нагрузкой (under load), то она отвечает сообщением cookie-reply.

### Обработка первого сообщения
Сторона, инициирующая соединение, отправляет следующее сообщение msg:
```
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!    type := 0x1 (1 байт)     !    reserved := 0^3 (3 байта)    !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!                     sender := Ii (4 байта)                    !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!                     ephemeral (33 байта)                      !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!                 static (33 байта + 16 байтов)                 !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!              timestamp  (12 байтов + 16 байтов)               !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!        mac1 (32 байта)       !        mac2 (32 байта)         !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
Формирование полей mac1 и mac2 описано в разделе "Вычисление кодов аутентификации сообщений".
Значение Ii генерируется случайным образом.
Остальные поля вычисляются следующим образом:
```
si-pub := MarshallCompressed(Si-pub)
sr-pub := MarshallCompressed(Sr-pub)
Ci := Hash(Construction)
Hi := Hash(Ci || Identifier)
Hi := Hash(Hi || sr-pub)
(Eipriv, Eipub) := DH-Generate()
ei-pub := MarshallCompressed(Ei-pub)
Ci := KDF1(Ci, ei-pub)
msg.ephemeral := ei-pub
Hi := Hash(Hi || msg.ephemeral)
(Ci, K) := KDF2(Ci, DH(Ei-priv, Sr-pub))
msg.static := AEAD-Encrypt(K, 0, si-pub, Hi)
Hi := Hash(Hi || msg.static)
(Ci , K) := KDF2(Ci, DH(Si-priv, Sr-pub))
msg.timestamp := AEAD-Encrypt(K, 0, Timestamp(), Hi)
Hi := Hash(Hi || msg.timestamp)
```

Отвечающая сторона при получении данного сообщения выполняет следующие вычисления:
```
sr-pub := MarshallCompressed(Sr-pub)
Cr := Hash(Construction)
Hr := Hash(Cr || Identifier)
Hr := Hash(Hr || sr-pub)
ei-pub := msg.ephemeral
Ei-pub := UnmarshallCompressed(ei-pub)
Cr := KDF1(Cr, ei-pub)
Hr := Hash(Hr || msg.ephemeral)
(Cr, K) := KDF2(Cr, DH(Sr-priv, Ei-pub))
si-pub := AEAD-Decrypt(K, 0, si-pub, Hr)
Si-pub := UnmarshallCompressed(si-pub)
Hr := Hash(Hr || msg.static)
(Cr , K) := KDF2(Cr, DH(Sr-priv, Si-pub))
timestamp := AEAD-Decrypt(K, 0, msg.timestamp, Hr)
Hr := Hash(Hr || msg.timestamp)
```
В результате выполненных вычислений состояния сторон должны быть идентичными: Ci = Cr, Hi = Hr.

### Обработка второго сообщения
Отвечающая сторона отправляет сообщение следующего вида после обработки первого сообщения, полученного от инициатора.

```
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!    type := 0x2 (1 байт)     !    reserved := 0^3 (3 байта)    !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!                     sender := Ir (4 байта)                    !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!                    receiver := Ii (4 байта)                   !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!                     ephemeral (33 байта)                      !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!        mac1 (32 байта)       !        mac2 (32 байта)         !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

Формирование полей mac1 и mac2 описано в разделе "Вычисление кодов аутентификации сообщений".
Значение Ir генерируется случайным образом. Остальные поля вычисляются следующим образом:
```
(Er-priv, Er-pub) := DH-Generate()
er-pub := MarshallCompressed(Er-pub)
msg.ephemeral := er-pub
Cr := KDF1(Cr, er-pub)
Hr := Hash(Hr || msg.ephemeral)
Cr := KDF1(Cr, DH(Er-priv, Ei-pub))
Cr := KDF1(Cr, DH(Er-priv, Si-pub))
(Cr, τ, K) := KDF3(Cr, Q)
Hr := Hash(Hr || τ)
msg.empty := AEAD-Encrypt(K, 0, ε, Hr)
Hr := Hash(Hr || msg.empty)
```

Когда инициатор получает данное сообщение он выполняет следующие вычисления:
```
er-pub := msg.ephemeral
Er-pub := UnmarshallCompressed(er-pub)
Ci := KDF1(Ci, er-pub)
Hi := Hash(Hi || msg.ephemeral)
Ci := KDF1(Ci, DH(Ei-priv, Er-pub))
Ci := KDF1(Ci, DH(Si-priv, Er-pub))
(Ci, τ, K) := KDF3(Ci, Q)
Hi := Hash(Hi || τ)
Hi := Hash(Hi || msg.empty)
msg.empty := AEAD-Decrypt(K, 0, ε, Hi)
```
В результате выполненных вычислений состояния сторон должны быть идентичными: Ci = Cr, Hi = Hr.

### Вычисление кодов аутентификации сообщений
Сообщения протокола Handshake содержат поля mac1 и mac2.
Пусть msg-ɑ и msg-ϐ обозначает все байты первого или второго сообщений Handshake до полей mac1 и mac2 соответственно.
Обозначим через L* значение cookie, полученное ℒ* секунд назад.
Тогда поля mac1 и mac2 формируются следующим образом:
```
msg.mac1 := HMAC(Hash(Label-MAC1 || Sm’-pub), msg-ɑ)
Если Lm = ε или ℒm≥120, то msg.mac2 := 0^32, иначе msg.mac2 := HMAC(Lm, msg-ϐ)
```

### Вычисление ключевого материала
После обмена двумя сообщениями в рамках протокола Handshake обе стороны вычисляют ключевой материал (transport data key)
и начальное значение счетчиков для шифрования и расшифрования транспортных сообщений следующим образом:
```
(Ti-send = Tr-recv, Tr-send = Ti-recv) := KDF2(Ci = Cr, ε)
Ni-send = Nr-recv = Ni-recv = Nr-send := 0
```
После этого каждая сторона выполняет обнуление значений эфемерных ключей и переменной Cm:
```
Ei-priv = Ei-pub = Er-priv = Er-pub = Ci = Cr := ε
```

### Защита данных
Зашифрованные инкапсулированные IP-пакеты передаются в транспортных сообщениях msg следующего вида:
```
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!    type := 0x4 (1 байт)     !    reserved := 0^3 (3 байта)    !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!                    receiver := Im’ (4 байта)                  !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!                       counter (8 байт)                        !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!                     packet (|P| + 16 байт)                    !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

Пусть P обозначает инкапсулированный IP-пакет. Тогда значения полей receiver, counter, packet формируются следующим образом:
```
P := P || 0^Z, Z = 16 ⌈|P| / 16⌉ – |P|
msg.counter = Nm-send
A := msg.type || msg.reserved || Im || Im’
msg.packet = AEAD (Tm-send, Nm-send, P, A)
Nm-send := Nm-send + 1
```

Получатель сообщения использует ключ Tm'-recv для расшифрования сообщения.
В заголовке транспортного сообщения отсутствует поле для длины сообщения, так как для проверки корректности полученного сообщения используется имитовставка.
Кроме того, поле для длины содержится в IP-заголовке инкапсулированного пакета.
Поле msg.counter содержит уникальный вектор, использующийся в формировании ICN шифра Кузнечик в режиме MGM.
Каждая сторона протокола ведет счетчик Nm-send: инициатор – Ni-send, а ответчик – Nr-recv.

Примечание. В соответствии с оригинальной спецификацией WireGuard (см. пункт 6.5) для определения состояния противоположной стороны используются keepalive сообщения.
Это обычные транспортные сообщения, в которых открытый текст P является пустой строкой.
В WireGuard при шифровании транспортных сообщений значением дополнительных данных A также является пустая строка.
Таким образом, значение |P| + |A| равно нулю. Это нарушает спецификацию MGM:
“The length of the associated data A and of the plaintext P MUST be such that 0 < |A| + |P| < 2^{n/2}.”
В связи с этим в Ru-WireGuard дополнительные данные A для транспортных сообщений строятся на основе значения поля type,
значения поля reserved, индекса инициатора и индекса ответчика.

### Формирование сообщения Cookie Reply
Когда сторона находится под воздействием DoS-атаки (under load) и получает от другой стороны с IP-адресом равным IPm’ и UDP-портом равным Portm’
сообщение протокола Handshake с корректным значением поля mac1, но некорректным значением mac2,
то первая сторона может отправить сообщение cookie reply следующего вида:
```
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!    type := 0x3 (1 байт)     !    reserved := 0^3 (3 байта)    !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!                    receiver := Im’ (4 байта)                  !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!                       nonce (16 байт)                         !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
!                     cookie (32 + 16 байт)                     !
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

Значения полей данного сообщения формируются следующим образом:

1. Поле msg.receiver содержит значение Im’ равное значению поля sender входящего сообщения.
1. В поле msg.nonce записывается 128-битное (16-байтное) значение, сгенерированное случайным образом.
1. msg.cookie := AEAD-Encrypt(Hash(Label-Cookie || Sm-pub), nonce, τ, M), где 
τ :=HMAC(Rm, Am’), Rm - 256-битное случайное значение, обновляемое каждые две минуты, Am’ = IPm’ || Portm', M - значение поля mac1 входящего сообщения, nonce := msg.nonce, nonce[1]:=0.

Примечание. В оригинальном протоколе WireGuard для генерации cookie используется шифр XChaCha20-Poly1305,
поддерживающий nonce размером 24 байта.
Ru-WireGuard использует максимально возможный размер nonce равный 127 бит в соответствии со спецификацией MGM.

## Контрольные вектора

Закрытый статический ключ инициатора:
```
00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f
10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f
```

Закрытый эфемерный ключ инициатора:
```
21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 
31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f 40
```

Закрытый статический ключ ответчика:
```
01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10
11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20
```

Закрытый эфемерный ключ ответчика:
```
20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 
30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f
```

Msg1:
```
72 75 20 77 69 72 65 67 75 61 72 64 20 74 65 73
74 20 6d 65 73 73 61 67 65 20 31 2d 2d 2d 2d 2d
```

Msg2:
```
72 75 20 77 69 72 65 67 75 61 72 64 20 74 65 73
74 20 6d 65 73 73 61 67 65 20 32 2d 2d 2d 2d 2d
```

PSK:
```
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
```

Значение C инициатора после отправки первого handshake-сообщения:
```
69 b5 cc 4a 8d 69 56 32 5b 0a b2 93 9a 3f ad 63
40 00 cd b9 e0 b6 47 10 1a 32 58 05 77 2f e1 3d
```

Значение C инициатора после получения второго handshake-сообщения:
```
22 bf 0e 8b e8 21 32 d8 ee 3f 2d 0e c5 2d 27 f5
42 b5 68 9b 77 8e b8 f2 b1 96 65 b6 94 94 e2 7c
```

Сообщение msg1, зашифрованное инициатором:
```
9d 65 2a a2 8d 7c 6a be f1 f7 f4 db dc 8b 37 45
af 77 6c c2 ef 10 19 90 66 bc af 17 92 03 ed d5
b7 4e 9a b6 a2 fa ea ca 96 94 53 99 47 d3 d4 42
```
Сообщение msg2, зашифрованное ответчиком:
```
c1 1b 69 a0 43 ff 5b 77 af d1 b6 b1 b0 ec aa 3a
3f 6e 46 cc 40 81 4b 50 d9 9b 49 17 9e 00 ff a7
6a 2a ab 6c 6a 4b f6 c6 23 59 e3 98 5e ca 13 84
```
